# =============================================================================
# カスタムシェル関数定義ファイル
# fzfを使ったインタラクティブな選択機能とzellij補完を提供
# =============================================================================

# -----------------------------------------------------------------------------
# tmuxステータスバー用シェル状態追跡
# preexec: コマンド実行前に「running」を記録
# precmd: コマンド実行後に終了コードに応じて「idle」または「error」を記録
# -----------------------------------------------------------------------------
if [[ -n "$TMUX" ]]; then
    _SHELL_STATE_DIR="${XDG_RUNTIME_DIR:-/tmp}/claude-code-state"
    mkdir -p "$_SHELL_STATE_DIR"

    # コマンド実行前: running状態を記録
    _tmux_shell_preexec() {
        local pane_id
        pane_id=$(tmux display-message -p '#{pane_id}' 2>/dev/null)
        [[ -n "$pane_id" ]] && echo "running" > "$_SHELL_STATE_DIR/shell-${pane_id#%}"
    }

    # コマンド実行後: 終了コードに応じて状態を記録
    _tmux_shell_precmd() {
        local exit_code=$?
        local pane_id
        pane_id=$(tmux display-message -p '#{pane_id}' 2>/dev/null)
        if [[ -n "$pane_id" ]]; then
            if [[ $exit_code -eq 0 ]]; then
                echo "idle" > "$_SHELL_STATE_DIR/shell-${pane_id#%}"
            else
                echo "error" > "$_SHELL_STATE_DIR/shell-${pane_id#%}"
            fi
        fi
    }

    # フックを登録（既存のフックを上書きしないよう配列に追加）
    autoload -Uz add-zsh-hook
    add-zsh-hook preexec _tmux_shell_preexec
    add-zsh-hook precmd _tmux_shell_precmd
fi

# -----------------------------------------------------------------------------
# ghqで管理しているリポジトリをfzfで検索してcdする関数
# キーバインド: Ctrl+]
# -----------------------------------------------------------------------------
function ghq_repo_search_with_fzf() {
    local selected_dir
    # ghq list -p: ghqで管理している全リポジトリのフルパスを一覧表示
    # fzf: インタラクティブなフィルタリング（--queryで現在のコマンドラインを初期クエリに）
    selected_dir=$(ghq list -p | fzf --query "$LBUFFER" --height 40% --reverse)
    # 選択されたディレクトリがあればcdコマンドを実行
    if [ -n "$selected_dir" ]; then
        BUFFER="cd ${selected_dir}"  # コマンドラインバッファにcdコマンドをセット
        zle accept-line              # Enterキーを押したのと同じ動作（コマンド実行）
    fi
    zle clear-screen  # 画面をクリアして再描画
}
# zleウィジェットとして登録し、Ctrl+]にバインド
zle -N ghq_repo_search_with_fzf
bindkey '^]' ghq_repo_search_with_fzf

# -----------------------------------------------------------------------------
# コマンド履歴をfzfで検索する関数
# キーバインド: Ctrl+R
# -----------------------------------------------------------------------------
function history_search_with_fzf() {
    # fc -ln 1: 履歴を番号なしで1番目から表示（zsh用）
    # awk '!a[$0]++': 重複を除去（最初に出現したものだけ残す）
    # fzf --tac: 逆順表示（新しいものが上に来る）
    BUFFER=$(fc -ln 1 | awk '!a[$0]++' | fzf --height 40% --reverse --tac)
    CURSOR=$#BUFFER    # カーソルをコマンドの末尾に移動
    zle reset-prompt   # プロンプトを再描画
}
# zleウィジェットとして登録し、Ctrl+Rにバインド
zle -N history_search_with_fzf
bindkey '^R' history_search_with_fzf

# -----------------------------------------------------------------------------
# zellijセッション名の補完関数
# zea（attach）とzed（delete）エイリアス用の補完を提供
# -----------------------------------------------------------------------------
function _zellij_sessions() {
    local sessions
    # zellij list-sessions: 既存のセッション一覧を取得
    # --no-formatting: 装飾なしのプレーンテキストで出力
    # awk '{print $1}': セッション名（最初のフィールド）のみ抽出
    # ${(f)"..."}: 改行で分割して配列に格納（zsh特有の構文）
    sessions=(${(f)"$(zellij list-sessions --no-formatting 2>/dev/null | awk '{print $1}')"})
    _describe 'session' sessions  # 補完候補として登録
}
# zeaとzedエイリアスにこの補完関数を適用（zellijがある場合のみ）
type zellij >/dev/null 2>&1 && compdef _zellij_sessions zea zed

# -----------------------------------------------------------------------------
# メモコマンド
# macOS: メモアプリに追加 / Linux: ~/memo ディレクトリにファイルとして保存
# 使い方:
#   memo "メモの内容"     - 引数でメモを追加
#   memo                  - エディタでメモを作成
#   memo -l               - メモ一覧を表示（Linuxのみ）
# -----------------------------------------------------------------------------
function memo() {
    local content=""
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")

    # オプション処理
    if [[ "$1" == "-l" ]]; then
        if [[ "$(uname)" == "Darwin" ]]; then
            echo "メモアプリを開いてください"
            open -a Notes
        else
            local memo_dir="${HOME}/memo"
            if [[ -d "$memo_dir" ]]; then
                ls -lt "$memo_dir"
            else
                echo "メモがありません"
            fi
        fi
        return 0
    fi

    # メモ内容の取得
    if [[ -n "$1" ]]; then
        # 引数がある場合はそれをメモ内容とする
        content="$*"
    else
        # 引数がない場合はエディタを開く
        local tmpfile=$(mktemp)
        nano "$tmpfile"
        if [[ -s "$tmpfile" ]]; then
            content=$(cat "$tmpfile")
        fi
        rm -f "$tmpfile"
    fi

    # メモ内容がなければ終了
    if [[ -z "$content" ]]; then
        echo "メモが空のため保存しませんでした"
        return 1
    fi

    # OS別の保存処理
    if [[ "$(uname)" == "Darwin" ]]; then
        # macOS: AppleScriptでメモアプリに追加
        osascript <<EOF
tell application "Notes"
    tell account "iCloud"
        make new note at folder "Notes" with properties {name:"CLI Memo - ${timestamp}", body:"${content}"}
    end tell
end tell
EOF
        if [[ $? -eq 0 ]]; then
            echo "メモを保存しました: CLI Memo - ${timestamp}"
        else
            echo "メモの保存に失敗しました"
            return 1
        fi
    else
        # Linux: ~/memo ディレクトリにファイルとして保存
        local memo_dir="${HOME}/memo"
        mkdir -p "$memo_dir"
        local filename=$(date "+%Y%m%d_%H%M%S").txt
        echo "$content" > "${memo_dir}/${filename}"
        echo "メモを保存しました: ${memo_dir}/${filename}"
    fi
}
